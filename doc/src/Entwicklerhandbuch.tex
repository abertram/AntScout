\chapter{Entwicklerhandbuch}
\label{chap:entwicklerhandbuch}

\section{Entwicklungskonfiguration}
\label{sec:entwicklungskonfiguration}

\subsection{Hardware}
\label{sec:hardware}

\begin{description}
  \item[Prozessor] Intel Core i5-2520M, 4 $\times$ 2.50 GHz
  \item[Speicher] 7,6 GiB
  \item[Grafikkarte] Intel Sandybridge Mobile
\end{description}

\subsection{Software}
\label{sec:software}

\begin{description}
  \item[Betriebssystem] Ubuntu 12.10, 64 Bit
  \item[\ac{ide}] IntelliJ IDEA 11.1.4
\end{description}

\subsubsection{Programmiersprachen}
\label{sec:programmiersprachen}

\begin{description}
  \item[Scala\footnotemark] \footnotetext{\url{http://www.scala-lang.org/}} wird im Back-End als Programmiersprache eingesetzt, da diese dank dem Aktorenkonzept die Entwicklung von nebenläufigen Anwendungen vereinfacht.
    Scala läuft auf der \ac{jvm} und ist damit plattformunabhängig.
  \item[CoffeeScript\footnotemark] \footnotetext{\url{http://coffeescript.org/}} kommt im Front-End zum Einsatz.
    Diese JavaScript ähnliche Sprache transkompiliert in JavaScript.
    CoffeeScript verbessert die Lesbarkeit von JavaScript und führt zusätzliche Funkionalität wie ``List Comprehension'' oder ``Pattern Matching'' ein.
\end{description}

\subsubsection{Bibliotheken}
\label{sec:bibliotheken}

\begin{description}
  \item[Config\footnotemark] \footnotetext{\url{https://github.com/typesafehub/config}} ermöglicht es, eine textbasierte Konfiguration für eine Anwendung zu erstellen.
    Es werden verschiedene Formate unterstützt.
    Zusätzlich stehen verschiedene Methoden zur Verfügung, um den Inhalt der Konfiguration auszulesen.
  \item[Lift\footnotemark] \footnotetext{\url{http://liftweb.net/}} ist ein mächtiges und sicheres Web-Framework.
    Damit ist es in Scala möglich Webanwendungen zu erstellen.
  \item[jQuery\footnotemark] \footnotetext{\url{http://jquery.com/}} ist eine JavaScript-Bibliothek und vereinfacht in JavaScript den Umgang mit HTML, Events oder Ajax.
  \item[Leaflet\footnotemark] \footnotetext{\url{http://leafletjs.com/}} ist eine kleine und moderne Bibliothek, die für die Darstellung interaktiver Karten genutzt wird.
  \item[RequireJS\footnotemark] \footnotetext{\url{http://requirejs.org/}} dient der Modularisierung von JavaScript.
  \item[Underscore\footnotemark] \footnotetext{\url{http://underscorejs.org/}} erweitert JavaScript um viele nützliche Funktionen.
\end{description}

\subsubsection{Erstellung}
\label{sec:erstellung}

Die Erstellung wird mit \ac{sbt}\footnote{\url{http://www.scala-sbt.org/}} realisiert, einem Standardwerkzeug, das in der Scala-Welt für diesen Zweck genutzt wird.

\section{Design und Implementierung}
\label{sec:design-und-implementierung}

In den folgenden Abschnitten wird die Implementierung der ersten Teilaufgabe von AntScout beschrieben und die zugrunde liegenden Designentscheidungen diskutiert.
Es wird nur grob auf die Abläufe und Verfahren eingegangen.
Detaillierte Ausführungen können dem gut dokumentierten Sourcecode entnommen werden.

\subsection{Architektur}
\label{sec:architektur}

In der Abbildung \ref{fig:architektur} ist die Architektur von AntScout abgebildet.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Bilder/Architektur.pdf}
  \caption{Architektur}
  \label{fig:architektur}
\end{figure}

\subsection{Kartenabruf}
\label{sec:kartenabruf}

\ac{osm} stellt ein \ac{rest}-\ac{api} zum Kartenabruf im \ac{xml}-Format zur Verfügung.
Es wird allerdings eine andere Möglichkeit genutzt, um die \ac{osm}- und auch lokale Ressourcen zu schonen.
Regelmäßig aktualisierte \ac{osm}-Karten nach Regionen unterteilt werden auch kostenlos von verschiedenen Dienstleistern angeboten.
Es wird die Hamburg-Karte vom Dienstleister Geofabrik heruntergeladen und vorverarbeitet.
Für die Vorverarbeitung von \ac{osm}-Karten wird die Anwendung Osmosis\footnote{\url{http://wiki.openstreetmap.org/wiki/Osmosis}} genutzt.
Die Karte wird im ersten Schritt gefiltert, sodass nur relevante Wege überbleiben und Knoten, die zu diesen Wegen gehören.
Im zweiten Schritt werden aus der ursprünglichen Karte rechteckige Ausschnitte extrahiert.
Diese Ausschnitte werden anschließend in AntScout geladen und weiterverarbeitet.

\ac{sbt} bietet die Möglichkeit, beliebige Aufgaben als sogenannte Tasks zu implementieren.
Zwischen diesen und bereits existierenden Tasks können Abhängigkeiten definiert werden.
Damit die Vorverarbeitungsschritte nicht jedes mal manuell ausgeführt werden müssen, wurden diese als \ac{sbt}-Tasks umgesetzt und werden bei Bedarf vor dem Start der Anwendung ausgeführt.
Die ausführlich dokumentierte Umsetzung ist in der Datei \texttt{project/Build.scala} zu finden.

\subsection{Kartenimport}
\label{sec:kartenimport}

Nach dem Start der Anwendung wird die in der Konfiguration definierte Karte geladen.
Die Karte wird durch einen globalen Singleton \texttt{OsmMap} repräsentiert, damit auf die Daten aus jeder anderen Klasse zugegriffen werden kann.
Zuerst werden die Knoten geladen.
Aus jedem Knoten wird eine \texttt{OsmNode}-Instanz erzeugt und in \texttt{OsmMap} gespeichert.
Im nächsten Schritt werden die Wege geladen.
Hier werden während des Ladevorganges verschiedene Wegeigenschaften - Tags genannt - wie Wegklasse, Name oder maximale Geschwindigkeit analysiert.
Die Bestimmung der maximalen Geschwindigkeit ist in drei Stufen realisiert:

\begin{enumerate}
  \item Es wird angenommen, dass die maximale Geschwindigkeit im \texttt{maxspeed}-Tag definiert ist.
    Es wird versucht den Wert dieses Tags auszulesen.
    Im Falle einer gültigen Zahl wird angenommen, dass der Wert in km/h angegeben ist und in m/s umgewandelt.
  \item Ist das \texttt{maxspeed}-Tag nicht vorhanden oder der Wert keine gültige Zahl, wird versucht die maximale Geschwindigkeit anhand der Wegklasse zu bestimmen.
    Diese ist im \texttt{highway}-Tag definiert.
    In der Konfiguration ist für jede Wegklasse eine Standardgeschwindigkeit abgelegt.
    Wenn die definierte Wegklasse mit einer der Wegklassen aus der Konfiguration übereinstimmt, wird diese Geschwindigkeit verwendet.
  \item Wenn die beiden ersten Schritte nicht erfolgreich sind, wird im letzten Schritt eine in der Konfiguration definierte Standardgeschwindigkeit verwendet.
\end{enumerate}

Im letzten Schritt des Wegladevorganges wird überprüft, ob der Weg eine Einbahnstraße repräsentiert.
Je nach Ergebnis wird eine \texttt{OsmOneWay}- oder \texttt{OsmWay}-Instanz erzeugt und in \texttt{OsmMap} gespeichert.

Im letzten Schritt des Kartenladevorganges wird eine Adjazenzmatrix ähnliche Datenstruktur berechnet.
Es handelt sich um eine Abbildung von Knoten auf Wege, die diesen Knoten als Bestandteil haben.

\subsection{Kartenumwandlung}
\label{sec:kartenumwandlung}

Die Umwandlung der \ac{osm}-Karte in einen AntNet-Graphen, der auch durch einen globalen Singleton \texttt{AntMap} repräsentiert wird, geschieht in mehreren Schritten.

\subsubsection{Filterung}
\label{sec:filterung}

Die Anzahl der in AntNet erzeugten Ameisen hängt von der Größe der Karte bzw. der Anzahl der Knoten ab.
Um die Anzahl der Ameisen und damit auch die Computerlast, auf dem die Anwendung läuft, zu reduzieren, werden die nicht relevanten Wege im ersten Schritt herausgefiltert.
Die relevanten Wege sind in der Konfiguration definiert:

\begin{lstlisting}
relevant-highways = [motorway,motorway_link,trunk,trunk_link,primary,primary_link,secondary,secondary_link,tertiary]
\end{lstlisting}

\subsubsection{Reduzierung}
\label{sec:reduzierung}

In AntNet werden in regelmäßigen Zeitintervallen an jedem Knoten Ameisen erzeugt.
Im zweiten Schritt wird die Anzahl der Knoten auf ein Minimum reduziert.
Für AntNet sind nur Knoten relevant, die Straßenenden und Kreuzungen repräsentieren.
Das sind alle Knoten vom Grad $= 1$ und Grad $\geq 3$.
Alle Straßen(-segmente), die durch Knoten vom Grad $= 2$ verbunden sind, werden zu einem \texttt{AntWay} oder \texttt{AntOneWay}, wenn es sich um einen Weg handelt, der eine Einbahnstraße repräsentiert, zusammengefasst und in \texttt{AntMap} gespeichert.

\subsubsection{Knotenberechnung}
\label{sec:knotenberechnung}

Nach der Zusammenfassung der Wege, werden die endgültigen Knoten für AntNet berechnet.
Die relevanten Knoten setzen sich aus Start- und Endknoten der zusammengefassten Wege zusammen.

\subsubsection{Aus- und eingehende Wege}
\label{sec:aus-und-eingehende-wege}

Eine Straßenkarte kann nur durch einen gerichteten Graphen repräsentiert werden.
In diesem letzten Schritt werden zwei Abbildungen berechnet.
Eine repräsentiert die ausgehenden und die andere die eingehenden Wege pro Knoten.

\subsection{\acs*{rest}}
\label{sec:rest}

Das Back-End bietet ein \ac{rest}-\ac{api} an, um z.B. die Knoten oder die Wege abzufragen.
In der Tabelle \ref{tab:rest-api} ist eine Übersicht der zur Verfügung stehenden Methoden abgebildet.
Sowohl die Parameter an das \ac{api} als auch deren Antwort sind im \ac{json}-Format.

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\textwidth}{lllX}
    Ressource & Methode & Parameter & Antwort \\
    \toprule
    \texttt{node/\{node-id\}} & GET & - & Aus- und eingehende Wege des Knoten mit der Id \{node-id\}. \\
    \midrule
    \texttt{nodes} & GET & - & Alle \texttt{AntMap}-Knoten. \\
    \midrule
    \texttt{ways} & GET & - & Alle \texttt{AntMap}-Wege. \\
    \midrule
    \texttt{way/\{way-id\}} & GET & - & Daten des \texttt{AntMap}-Weges mit der Id \{way-id\}. \\
    \midrule
    \texttt{way/\{way-id\}} & PUT & \texttt{maxSpeed: \{maxSpeed\}} & Daten des veränderten \texttt{AntMap}-Weges mit der Id \{way-id\}. \\
    \bottomrule
  \end{tabularx}
  \caption{\acs*{rest}-\acs*{api}}
  \label{tab:rest-api}
\end{table}

\section{Grundlegende Datenstrukturen}
\label{sec:grundlegende-datenstrukturen}

\subsection{OsmMap}
\label{sec:osm-map}

In diesem Singleton sind die Knoten und Wege gespeichert, die direkt aus den \ac{osm}-Daten geladen werden.
Zusätzlich ist hier die Abbildung von Knoten auf die adjazenten Wege zu finden.

\subsection{AntMap}
\label{sec:ant-map}

Diese Datenstruktur ist auch ein Singleton.
Hier sind die Knoten und Wege zu finden, die für den AntNet-Algorithmus relevant sind.
Diese Daten werden genutzt, um die \ac{rest}-Anfragen zu beantworten.

\section{Tests}
\label{sec:tests}

Während der Entwicklung wurde die Anwendung immer wieder gestartet und geprüft, ob sie sich erwartungsgemäß verhält.
Zusätzlich zum normalen Ablauf wurden immer wieder gewisse (Fehler-)Situationen provoziert und das Verhalten getestet.
