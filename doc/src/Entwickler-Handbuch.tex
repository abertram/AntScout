\chapter{Entwickler-Handbuch}
\label{chap:entwickler-handbuch}

\section{Entwicklungs-Konfiguration}
\label{sec:entwicklungs-konfiguration}

\subsection{Hardware}
\label{sec:hardware}

\begin{description}
  \item[Prozessor] Intel Core i5-2520M, 4 $\times$ 2.50 GHz
  \item[Speicher] 7,6 GiB
  \item[Grafik-Karte] Intel Sandybridge Mobile
\end{description}

\subsection{Software}
\label{sec:software}

\begin{description}
  \item[Betriebs-System] Ubuntu 12.10, 64 Bit
  \item[\gls{ide}] IntelliJ IDEA 11.1.4
\end{description}

\subsubsection{Programmier-Sprachen}
\label{sec:programmier-sprachen}

\begin{description}
  \item[Scala] wird im Back-End als Programmier-Sprache eingesetzt, da diese dank dem Aktoren-Konzept die Entwicklung von nebenläufigen Anwendungen vereinfacht.
    Scala läuft auf der \gls{jvm} und ist damit Plattform-unabhängig.
  \item[CoffeeScript] kommt im Front-End zum Einsatz.
    Diese JavaScript-ähnliche Sprache transkompiliert in JavaScript.
    CoffeeScript verbessert die Lesbarkeit von JavaScript und führt zusätzliche Funkionalität wie ``List Comprehension'' oder ``Pattern Matching'' ein.
\end{description}

\subsubsection{Bibliotheken}
\label{sec:bibliotheken}

\begin{description}
  \item[Config] ermöglicht es, eine Text-basierte Konfiguration für eine Anwendung zu erstellen.
    Es werden verschiedene Formate unterstützt.
    Zusätzlich stehen verschiedene Methoden zur Verfügung, um den Inhalt der Konfiguration auszulesen.
  \item[Lift] ist ein mächtiges und sicheres Web-Framework.
    Damit ist es in Scala möglich Web-Anwendungen zu erstellen.
  \item[jQuery] ist eine JavaScript-Bibliothek und vereinfacht in JavaScript den Umgang mit HTML, Events oder Ajax.
  \item[Leaflet] ist eine kleine und moderne Bibliothek, die für die Darstellung interaktiver Karten genutzt wird.
  \item[RequireJS] dient der Modularisierung von JavaScript.
  \item[Underscore] erweitert JavaScript um viele nützliche Funktionen.
\end{description}

\subsubsection{Erstellung}
\label{sec:erstellung}

Die Erstellung wird mit \gls{sbt} realisiert, einem Standard-Werkzeug, das in der Scala-Welt für diesen Zweck genutzt wird.

\section{Design und Implementierung}
\label{sec:design-und-implementierung}

In den folgenden Abschnitten wird die Implementierung der ersten Teil-Aufgabe von \textit{AntScout} beschrieben und die zugrunde liegenden Design-Entscheidungen diskutiert.
Es wird nur grob auf die Abläufe und Verfahren eingegangen.
Detaillierte Ausführungen können dem gut dokumentierten Source-Code entnommen werden.

\subsection{Architektur}
\label{sec:architektur}

In der Abbildung \ref{fig:architektur} ist die Architektur von \textit{AntScout} abgebildet.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Bilder/Architektur.pdf}
  \caption{Architektur}
  \label{fig:architektur}
\end{figure}

\subsection{Karten-Abruf}
\label{sec:karten-abruf}

\gls{osm} stellt eine \gls{rest}-\gls{api} zum Karten-Abruf im \gls{xml}-Format zur Verfügung.
Es wird allerdings eine andere Möglichkeit genutzt, um die \gls{osm}- und auch lokale Ressourcen zu schonen.
Regelmäßig aktualisierte \gls{osm}-Karten nach Regionen unterteilt werden auch kostenlos von verschiedenen Dienst-Leistern angeboten.
Es wird die Hamburg-Karte vom Dienst-Leister \textit{Geofabrik} heruntergeladen und vorverarbeitet.
Für die Vorverarbeitung von \gls{osm}-Karten wird die Anwendung \textit{Osmosis}\footnote{\url{http://wiki.openstreetmap.org/wiki/Osmosis}} genutzt.
Die Karte wird im ersten Schritt gefiltert, sodass nur relevante Wege überbleiben und Knoten, die zu diesen Wegen gehören.
Im zweiten Schritt werden aus der ursprünglichen Karte rechteckige Ausschnitte extrahiert.
Diese Ausschnitte werden anschließend in AntScout geladen und weiterverarbeitet.

\gls{sbt} bietet die Möglichkeit, beliebige Aufgaben als sogenannte Tasks zu implementieren.
Zwischen diesen und bereits existierenden Tasks können Abhängigkeiten definiert werden.
Damit die Vorverarbeitungs-Schritte nicht jedes mal manuell ausgeführt werden müssen, wurden diese als \gls{sbt}-Tasks umgesetzt und werden bei Bedarf vor dem Start der Anwendung ausgeführt.
Die ausführlich dokumentierte Umsetzung ist in der Datei \texttt{project/Build.scala} zu finden.

\subsection{Karten-Import}
\label{sec:karten-import}

Nach dem Start der Anwendung wird die in der Konfiguration definierte Karte geladen.
Die Karte wird durch einen globalen Singleton \texttt{OsmMap} repräsentiert, damit auf die Daten aus jeder anderen Klasse zugegriffen werden kann.
Zuerst werden die Knoten geladen.
Aus jedem Knoten wird eine \texttt{OsmNode}-Instanz erzeugt und in \texttt{OsmMap} gespeichert.
Im nächsten Schritt werden die Wege geladen.
Hier werden während des Lade-Vorganges verschiedene Weg-Eigenschaften - Tags genannt - wie Weg-Klasse, Name oder maximale Geschwindigkeit analysiert.
Die Bestimmung der maximalen Geschwindigkeit ist in drei Stufen realisiert:

\begin{enumerate}
  \item Es wird angenommen, dass die maximale Geschwindigkeit im \texttt{maxspeed}-Tag definiert ist.
    Es wird versucht den Wert dieses Tags auszulesen.
    Im Falle einer gültigen Zahl wird angenommen, dass der Wert in km/h angegeben ist und in m/s umgewandelt.
  \item Ist das \texttt{maxspeed}-Tag nicht vorhanden oder der Wert keine gültige Zahl, wird versucht die maximale Geschwindigkeit anhand der Weg-Klasse zu bestimmen.
    Diese ist im \texttt{highway}-Tag definiert.
    In der Konfiguration ist für jede Weg-Klasse eine Standard-Geschwindigkeit abgelegt.
    Wenn die definierte Weg-Klasse mit einer der Weg-Klassen aus der Konfiguration übereinstimmt, wird diese Geschwindigkeit verwendet.
  \item Wenn die beiden ersten Schritte nicht erfolgreich sind, wird im letzten Schritt eine in der Konfiguration definierte Standard-Geschwindigkeit verwendet.
\end{enumerate}

Im letzten Schritt des Weg-Lade-Vorganges wird überprüft, ob der Weg eine Einbahn-Strasse repräsentiert.
Je nach Ergebnis wird eine \texttt{OsmOneWay}- oder \texttt{OsmWay}-Instanz erzeugt und in \texttt{OsmMap} gespeichert.

Im letzten Schritt des Karten-Lade-Vorganges wird eine Adjazenz-Matrix-ähnliche Daten-Struktur berechnet.
Es handelt sich um eine Abbildung von Knoten auf Wege, die diesen Knoten als Bestandteil haben.

\subsection{Karten-Umwandlung}
\label{sec:karten-umwandlung}

Die Umwandlung der \gls{osm}-Karte in einen \textit{AntNet}-Graphen, der auch durch einen globalen Singleton \texttt{AntMap} repräsentiert wird, geschieht in mehreren Schritten.

\subsubsection{Filterung}
\label{sec:filterung}

Die Anzahl der in \textit{AntNet} erzeugten Ameisen hängt von der Größe der Karte bzw. der Anzahl der Knoten ab.
Um die Anzahl der Ameisen und damit auch die Computer-Last, auf dem die Anwendung läuft, zu reduzieren, werden die nicht relevanten Wege im ersten Schritt herausgefiltert.
Die relevanten Wege sind in der Konfiguration definiert:

\begin{lstlisting}
relevant-highways = [motorway,motorway_link,trunk,trunk_link,primary,primary_link,secondary,tertiary]
\end{lstlisting}

\subsubsection{Reduzierung}
\label{sec:reduzierung}

In \textit{AntNet} werden in regelmäßigen Zeit-Intervallen an jedem Knoten Ameisen erzeugt.
Im zweiten Schritt wird die Anzahl der Knoten auf ein Minimum reduziert.
Für \textit{AntNet} sind nur Knoten relevant, die Kreuzungen repräsentieren.
Das sind alle Knoten vom Grad $\geq 3$.
Alle Strassen(-Segmente), die durch Knoten vom Grad $< 2$ verbunden sind, werden zu einem \texttt{AntWay} oder \texttt{AntOneWay}, wenn es sich um einen Weg handelt, der eine Einbahn-Strasse repräsentiert, zusammengefasst und in \texttt{AntMap} gespeichert.

\subsubsection{Knoten-Berechnung}
\label{sec:knoten-berechnung}

Nach der Zusammenfassung der Wege, werden die endgültigen Knoten für \textit{AntNet} berechnet.
Die relevanten Knoten sind alles Start- und End-Knoten der zusammengefassten Wege.

\subsubsection{Aus- und eingehende Wege}
\label{sec:aus-und-eingehende-wege}

Eine Strassen-Karte kann nur durch einen gerichteten Graphen repräsentiert werden.
In diesem letzten Schritt werden zwei Abbildungen berechnet.
Eine repräsentiert die ausgehenden und die andere die eingehenden Wege pro Knoten.

\subsection{REST}
\label{sec:rest}

Das Back-End bietet eine \gls{rest}-\gls{api} an, um z.B. die Knoten oder die Wege abzufragen.
In der Tabelle \ref{tab:rest-api} ist eine Übersicht der zur Verfügung stehenden Methoden abgebildet.
Sowohl die Parameter an die \gls{api} als auch deren Antwort sind im \gls{json}-Format.

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\textwidth}{l|l|l|X}
    Ressource & Methode & Parameter & Antwort \\
    \hline
    \texttt{node/\{node-id\}} & GET & - & Aus- und eingehende Wege des Knoten mit der Id \{node-id\}. \\
    \hline
    \texttt{nodes} & GET & - & Alle \texttt{AntMap}-Knoten. \\
    \hline
    \texttt{ways} & GET & - & Alle \texttt{AntMap}-Wege. \\
    \hline
    \texttt{way/\{way-id\}} & GET & - & Daten des \texttt{AntMap}-Weges mit der Id \{way-id\}. \\
    \hline
    \texttt{way/\{way-id\}} & PUT & \texttt{maxSpeed: \{maxSpeed\}} & Daten des veränderten \texttt{AntMap}-Weges mit der Id \{way-id\}. \\
  \end{tabularx}
  \caption{\gls{rest}-\gls{api}}
  \label{tab:rest-api}
\end{table}

\section{Grundlegende Datenstrukturen}
\label{sec:grundlegende-datenstrukturen}

\subsection{OsmMap}
\label{sec:osm-map}

In diesem Singleton sind die Knoten und Wege gespeichert, die direkt aus den \gls{osm}-Daten geladen werden.
Zusätzlich ist hier die Abbildung von Knoten auf die adjazenten Wege zu finden.

\subsection{AntMap}
\label{sec:Ant-map}

Diese Daten-Struktur ist auch ein Singleton.
Hier sind die Knoten und Wege zu finden, die für den \textit{AntNet}-Algorithmus relevant sind.
Diese Daten werden genutzt, um die \gls{rest}-Anfragen zu beantworten.

\section{Tests}
\label{sec:tests}

Während der Entwicklung wurde die Anwendung immer wieder gestartet und geprüft, ob sie sich erwartungsgemäß verhält.
Zusätzlich zum normalen Ablauf wurden immer wieder gewisse (Fehler-)Situationen provoziert und das Verhalten getestet.
